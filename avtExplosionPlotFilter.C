/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtExplosionPlotFilter.C
// ************************************************************************* //

#include <avtExplosionPlotFilter.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCell.h>
#include<DebugStream.h>
#include<vtkCellArray.h>


// ****************************************************************************
//  Method: avtExplosionPlotFilter constructor
//
//  Programmer: guillaume -- generated by xml2avt
//  Creation:   Wed Nov 27 11:45:02 PDT 2013
//
// ****************************************************************************

avtExplosionPlotFilter::avtExplosionPlotFilter()
{
    _scale = 0.5;
}


// ****************************************************************************
//  Method: avtExplosionPlotFilter destructor
//
//  Programmer: guillaume -- generated by xml2avt
//  Creation:   Wed Nov 27 11:45:02 PDT 2013
//
//  Modifications:
//
// ****************************************************************************

avtExplosionPlotFilter::~avtExplosionPlotFilter()
{
}


// ****************************************************************************
//  Method:  avtExplosionPlotFilter::Create
//
//  Programmer: guillaume -- generated by xml2avt
//  Creation:   Wed Nov 27 11:45:02 PDT 2013
//
// ****************************************************************************

avtFilter *
avtExplosionPlotFilter::Create()
{
    return new avtExplosionPlotFilter();
}


// ****************************************************************************
//  Method:      avtExplosionPlotFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: guillaume -- generated by xml2avtin_ds
//  Creation:   Wed Nov 27 11:45:02 PDT 2013
//
// ****************************************************************************

void
avtExplosionPlotFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ScaleVal*)a;
}


// ****************************************************************************
//  Method: avtExplosionPlotFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtExplosionPlotFilter with the given
//      parameters would result in an equivalent avtExplosionPlotFilter.
//
//  Programmer: guillaume -- generated by xml2avt
//  Creation:   Wed Nov 27 11:45:02 PDT 2013
//
// ****************************************************************************

bool
avtExplosionPlotFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ScaleVal*)a);
}


// ****************************************************************************
//  Method: avtExplosionPlotFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the ExplosionPlot filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: guillaume -- generated by xml2avt
//  Creation:   Wed Nov 27 11:45:02 PDT 2013
//
// ****************************************************************************

vtkDataSet *
avtExplosionPlotFilter::ExecuteData(vtkDataSet *input, int, std::string)
{

    _scale = atts.GetScal();
    if(_scale<0) _scale = 0;
    if(_scale>50) _scale = 50;
    debug5<<"scale : "<<_scale<<endl;

    vtkUnstructuredGrid * output = vtkUnstructuredGrid::New();
    vtkIdType nbCells = input->GetNumberOfCells();
    vtkPoints * points = vtkPoints::New();
    debug5<<"nbcells : "<<nbCells<<endl;

    for(int i = 0; i < nbCells; i++)
    {
        debug5<<"i : "<<i<<endl;
        vtkCell * triangle = input->GetCell(i);
        double * a = new double[3];
        input->GetPoint(triangle->GetPointId(0), a);
        debug5<<"a : "<<a[0]<<" "<<a[1]<<" "<<a[2]<<endl;
        double * b = new double[3];
        input->GetPoint(triangle->GetPointId(1), b);
        debug5<<"b : "<<b[0]<<" "<<b[1]<<" "<<b[2]<<endl;
        double * c = new double[3];
        input->GetPoint(triangle->GetPointId(2), c);
        debug5<<"c : "<<c[0]<<" "<<c[1]<<" "<<c[2]<<endl;

        double * normal = new double[3];
        this->GetTriangleNormal(a,b,c,normal);
        debug5<<"normal : "<<normal[0]<<" "<<normal[1]<<" "<<normal[2]<<endl;
        this->Normalize(normal);
        debug5<<"normal : "<<normal[0]<<" "<<normal[1]<<" "<<normal[2]<<endl;

        //After that we compute the new points coordonates
        double * temp = new double[3];
        this->Interpolate(a, normal, temp);
        points->InsertNextPoint(temp);
        debug5<<"newA : "<<temp[0]<<" "<<temp[1]<<" "<<temp[2]<<endl;

        temp = new double[3];
        this->Interpolate(b, normal, temp);
        points->InsertNextPoint(temp);
        debug5<<"newB : "<<temp[0]<<" "<<temp[1]<<" "<<temp[2]<<endl;

        temp = new double[3];
        this->Interpolate(c, normal, temp);
        points->InsertNextPoint(temp);
        debug5<<"newC : "<<temp[0]<<" "<<temp[1]<<" "<<temp[2]<<endl;

        vtkIdList * ids = vtkIdList::New();
        ids->SetNumberOfIds(3);
        ids->SetId(0, (i*3));
        ids->SetId(1, (i*3) + 1);
        ids->SetId(2, (i*3) + 2);

        debug5<<"ids : "<<ids->GetId(0)<<" "<<ids->GetId(1)<<" "<<ids->GetId(2)<<endl;

        output->InsertNextCell(VTK_TRIANGLE, ids);

        debug5<<"cell finish"<<endl<<endl<<endl;
    }

    output->SetPoints(points);
    points->Delete();

    return output;
}

void avtExplosionPlotFilter::Interpolate(double * A, double * normal, double * C)
{
    double * tempNorm = new double[3];
    tempNorm[0] = normal[0] * _scale;
    tempNorm[1] = normal[1] * _scale;
    tempNorm[2] = normal[2] * _scale;

    C[0] = tempNorm[0] + A[0];
    C[1] = tempNorm[1] + A[1];
    C[2] = tempNorm[2] + A[2];
}

void avtExplosionPlotFilter::GetTriangleNormal(double * A, double * B, double * C, double * N)
{

    double * AB = new double[3];
    AB[0] = B[0] - A[0];
    AB[1] = B[1] - A[1];
    AB[2] = B[2] - A[2];
    double * AC = new double[3];
    AC[0] = C[0] - A[0];
    AC[1] = C[1] - A[1];
    AC[2] = C[2] - A[2];

    debug5<<"AB : "<<AB[0]<<" "<<AB[1]<<" "<<AB[2]<<endl;
    debug5<<"AC : "<<AC[0]<<" "<<AC[1]<<" "<<AC[2]<<endl;

    N[0] = AB[1] * AC[2] - AB[2] * AC[1];
    N[1] = AB[2] * AC[0] - AB[0] * AC[2];
    N[2] = AB[0] * AC[1] - AB[1] * AC[0];

    debug5<<"N : "<<N[0]<<" "<<N[1]<<" "<<N[2]<<endl;
}

void avtExplosionPlotFilter::Normalize(double * N)
{
    double dist = N[0]*N[0] + N[1]*N[1] + N[2]*N[2];
    dist = sqrt(dist);
    debug5<<"dist : "<<dist<<endl;

    N[0] /= dist;
    N[1] /= dist;
    N[2] /= dist;
}
